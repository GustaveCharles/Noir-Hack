import "./chunk-KJQ4BY7K.js";

// node_modules/@noir-lang/noir_js/lib/index.mjs
import * as acvm from "@noir-lang/acvm_js";
import * as abi from "@noir-lang/noirc_abi";
import { ecdsa_secp256r1_verify, ecdsa_secp256k1_verify, blake2s256, xor, and } from "@noir-lang/acvm_js";

// node_modules/@noir-lang/noir_js/lib/witness_generation.mjs
import { abiDecodeError, abiEncode } from "@noir-lang/noirc_abi";

// node_modules/@noir-lang/noir_js/lib/base64_decode.mjs
function base64Decode(input) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(input, "base64");
  } else if (typeof atob === "function") {
    return Uint8Array.from(atob(input), (c) => c.charCodeAt(0));
  } else {
    throw new Error("No implementation found for base64 decoding.");
  }
}

// node_modules/@noir-lang/noir_js/lib/witness_generation.mjs
import { executeProgram } from "@noir-lang/acvm_js";
var defaultForeignCallHandler = async (name, args) => {
  if (name == "print") {
    return [];
  }
  throw Error(`Unexpected oracle during execution: ${name}(${args.join(", ")})`);
};
function parseErrorPayload(abi2, originalError) {
  const payload = originalError.rawAssertionPayload;
  if (!payload)
    return originalError;
  const enrichedError = originalError;
  try {
    const decodedPayload = abiDecodeError(abi2, payload);
    if (typeof decodedPayload === "string") {
      enrichedError.message = `Circuit execution failed: ${decodedPayload}`;
    } else {
      enrichedError.decodedAssertionPayload = decodedPayload;
    }
  } catch (_errorDecoding) {
  }
  return enrichedError;
}
async function generateWitness(compiledProgram, inputs, foreignCallHandler = defaultForeignCallHandler) {
  const witnessMap = abiEncode(compiledProgram.abi, inputs);
  try {
    const solvedWitness = await executeProgram(base64Decode(compiledProgram.bytecode), witnessMap, foreignCallHandler);
    return solvedWitness;
  } catch (err) {
    if (typeof err === "object" && err !== null && "rawAssertionPayload" in err) {
      throw parseErrorPayload(compiledProgram.abi, err);
    }
    throw new Error(`Circuit execution failed: ${err}`);
  }
}

// node_modules/@noir-lang/noir_js/lib/program.mjs
import initAbi, { abiDecode } from "@noir-lang/noirc_abi";
import initACVM, { compressWitnessStack } from "@noir-lang/acvm_js";
var Noir = class {
  circuit;
  constructor(circuit) {
    this.circuit = circuit;
  }
  /** @ignore */
  async init() {
    if (typeof initAbi === "function") {
      await Promise.all([initAbi(), initACVM()]);
    }
  }
  /**
   * @description
   * Allows to execute a circuit to get its witness and return value.
   *
   * @example
   * ```typescript
   * async execute(inputs)
   * ```
   */
  async execute(inputs, foreignCallHandler) {
    await this.init();
    const witness_stack = await generateWitness(this.circuit, inputs, foreignCallHandler);
    const main_witness = witness_stack[0].witness;
    const { return_value: returnValue } = abiDecode(this.circuit.abi, main_witness);
    return { witness: compressWitnessStack(witness_stack), returnValue };
  }
};
export {
  Noir,
  abi,
  acvm,
  and,
  blake2s256,
  ecdsa_secp256k1_verify,
  ecdsa_secp256r1_verify,
  xor
};
//# sourceMappingURL=@noir-lang_noir_js.js.map
